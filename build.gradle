
plugins {
	id "java"
	id "com.bmuschko.izpack" version "2.1"	// For building cross-platform installers
	id "nebula.ospackage" version "3.1.0"	// For building deb and rpm packages
	id "org.ajoberstar.github-pages" version "1.3.2"
}

version = "0.1-SNAPSHOT"
description = "Enhances Alice 3.2 STransport subclasses to include methods for interacting with the Finch robot"
sourceCompatibility = 1.6

detectAliceDir()

repositories {
	// Use 'jcenter' for resolving your dependencies.
	// You can declare any Maven/Ivy/file repository here.
	jcenter()

	//mavenCentral()
}

// Ensure the Java compilation tasks perform extra checks on the code
tasks.withType(JavaCompile) {
	options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
}

/**
 * Attempts to determine the root path of an Alice 3 installation.
 *
 * The path returned may be specified on the command line by passing -PaliceDir=/path/to/alice3
 * Otherwise, the following OS-specific defaults will be used:
 *   Windows: C:\Program Files\Alice 3
 *   Linux: ~/Alice3
 *   Mac OSX: ~/Alice3
 */
void detectAliceDir() {
	def rv = null
	if (project.hasProperty('aliceDir')) {
		rv = project.aliceDir;
	} else {
		def os = org.gradle.internal.os.OperatingSystem.current()
		if (os.isWindows()) {
			rv = "C:\\Program Files\\Alice 3"
		} else if (os.isMacOsX()) {
			rv = System.getProperty("user.home") +"/Alice3"
		} else if (os.isUnix()) {
			rv = System.getProperty("user.home") +"/Alice3"
		}
	}

	verifyAliceDir(rv)

	println "Alice installation detected at $aliceDir"
} // detectAliceDir

/**
 * Checks the specified path and ensures that it appears to be an Alice installation.
 * This method verifies the path exists, and that it contains two subfolders: 'lib' and 'ext'.
 * As a side-effect, this method also sets an aliceLibDir property on the project.
 * @param	path	The path to verify.
 */
void verifyAliceDir(String path) {
	if (!file("$path").exists())
		throw new java.io.FileNotFoundException("The specified Alice dir doesn't exist: $path")

	def libDir = file("$path/lib").getAbsolutePath()

	if (!file(libDir).exists())
		throw new java.io.FileNotFoundException("The Alice 'lib' dir doesn't exist: $libDir")

	if (fileTree(dir: libDir, include: '*.jar').size() == 0)
		throw new java.io.FileNotFoundException("The Alice 'lib' dir doesn't contain any Jar files: $libDir")

	def extDir = file("$path/ext").getAbsolutePath()

	if (!file(extDir).exists())
		throw new java.io.FileNotFoundException("The Alice 'ext' dir doesn't exist: $extDir")

	if (fileTree(dir: extDir, include: '*/').size() == 0)
		throw new java.io.FileNotFoundException("The Alice 'ext' dir doesn't contain any subfolders: $extDir")

/*	// Should only need this if we want to launch Alice, so omitting for now
	def exeName = (org.gradle.internal.os.OperatingSystem.current().isWindows() ? "Alice 3.exe" : "Alice3")
	if (!file("$path/$exeName").exists())
		throw new java.io.FileNotFoundException("Unable to find Alice executable: $path/$exeName")
*/

	project.ext.aliceDir = path
	project.ext.aliceLibDir = libDir
} // verifyAliceDir

/**
 * Returns the paths of all of the Jars in the Alice lib dir
 */
FileCollection aliceLibJars() {
	return fileTree(dir: aliceLibDir, include: "**/*.jar")
} // aliceLibJars

configurations {
	provided	// This configuration is used to append the Alice library Jars to the compile classpath without affecting the runtime classpath
}

// In this section you declare the dependencies for your production and test code
dependencies {
	// Determines the Alice library Jar paths
	provided aliceLibJars()

	// The production code uses the SLF4J logging API at compile time
	compile 'org.slf4j:slf4j-api:1.7.13'

	// Declare the dependency for your favourite test framework you want to use in your tests.
	// TestNG is also supported by the Gradle Test task. Just change the
	// testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
	// 'test.useTestNG()' to your build script.
	testCompile 'junit:junit:4.12'
}

// Append the Alice Jars to the compile class path
sourceSets.main.compileClasspath += configurations.provided

javadoc.classpath = sourceSets.main.compileClasspath

// Configuration for building the installer package using izpack
izpack {
	compression = 'deflate'
	compressionLevel = 9
	appProperties = [
		'app.group': 'finch4alice',
		'app.name': 'finch4alice',
		'app.title': 'Finch4Alice',
		'app.version': version,
		'app.subpath': "Finch4Alice-$version"
	]
}



ospackage {
	packageName = project.name
	summary = project.description

	os = LINUX

	url = "http://www.finch4alice.com/"

//	user = "root"
//	permissionGroup = "root"
	
/*
	installUtils file('scripts/rpm/utils.sh')
	preInstall file('scripts/rpm/preInstall.sh')
	postInstall file('scripts/rpm/postInstall.sh')
	preUninstall 'touch /tmp/myfile'
	postUninstall file('scripts/rpm/postUninstall.sh')

	requires('qux')

	into '/opt/foo'
*/

	from(jar.outputs.files) {
		into 'lib'
	}
	from(configurations.runtime) {
		into 'lib'
	}
	from('lib') {
		into 'lib'
	}
/*
	from('scripts') {
		into 'bin'
		exclude 'database'
		fileMode = 0550
	}
	from('src/main/resources') {
		fileType CONFIG | NOREPLACE
		into 'conf'
	}
	from('home') {
		// Creating directory entries (or not) in the RPM is normally left up to redline-rpm library.
		// Use this to explicitly create an entry -- for setting directory fileMode on system directories.
		createDirectoryEntry = true
		fileMode = 0500
		into 'home'
	}
	from('endorsed') {
		// Will tell redline-rpm not to auto create directories, which
		// is sometimes necessary to avoid rpm directory conflicts
		addParentDirs = false
		into '/usr/share/tomcat/endorsed'
	}
*/
}

buildRpm {
	arch = "NOARCH"

	// Do a little magic here, since RPM has different semantics for snapshot versions
	// https://fedoraproject.org/wiki/Packaging:NamingGuidelines#Version_Tag
	if (project.version ==~ /^.*-SNAPSHOT$/) {
		// We need to strip the -SNAPSHOT suffix from the version
		version = project.version.replaceFirst(/-SNAPSHOT$/, '')

		// And set the 'release' to indicate a snapshot release
		release = 'SNAPSHOT'+ new Date().format('yyyyMMddHHmmss')
	}
}

buildDeb {
	arch = "all"

	// Do a little magic here, since DEB has specific semantics for versions with hyphens in them
	// https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version
	// http://serverfault.com/questions/604541/debian-packages-version-convention
	if (project.version ==~ /^.*-SNAPSHOT$/) {
		// Add in a 'debian_revision' of 0 here to accommodate the Deb versioning requirements
		version += '-0'
	}
}

// Configure the 'prepareGhPages' and 'publishGhPages' tasks for updating the javadoc on gh-pages
// The project property 'gitSshKey' can be specified to provide a non-standard SSH key for authentication
githubPages {
	def docVersion = project.version.replaceFirst(/-SNAPSHOT$/, '')

	if (project.hasProperty('gitSshKey'))
		System.setProperty("org.ajoberstar.grgit.auth.ssh.private", gitSshKey)

	repoUri = 'git@github.com:bradcfisher/finch4alice.git'
	targetBranch = 'gh-pages'
	deleteExistingFiles = false
	commitMessage = "Updated javadoc for version "+ docVersion +" from gradle"
	pages {
		into "api/$docVersion"
		from javadoc
	}
}

task install(dependsOn: jar) {
	def optionsFile =
		"Alice 3.vmoptions."+
			(org.gradle.internal.os.OperatingSystem.current().isWindows() ? "windows" : "linux")

	// We use a the project.copy function here instead of inheriting from the Copy task
	// because we don't care about the up-to-date checks which the Copy task will perform.
	// Since the target folders already have files in them, those checks are expensive
	// and waste a lot of time during the install.
	copy {
		eachFile { println "Copying "+ it }

		into aliceDir

		from("src/main/resources") {
			include optionsFile
			rename ".*", "Alice 3.vmoptions"
		}

		from("${buildDir.name}/libs") {
			into "ext/finch4alice"
			include "finch4alice-*.jar"
			rename ".*", "finch4alice.jar"
		}
	}
}
